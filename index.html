<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steamboat Planner - レトロスケジュール帳</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 油性マジック (Yusei Magic) フォントの読み込み -->
    <link href="https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap" rel="stylesheet">
    <style>
        /* グローバル設定とカスタムCSS */
        :root {
            --color-white: #FEFEFE;
            --color-black: #111827;
            --color-yellow: #FFC72C; /* スロット、警告 */
            --color-red: #D32F2F;   /* アクティブ、点滅コロン */
        }
        body {
            /* 手書き感のあるフォントに変更 */
            font-family: 'Yusei Magic', cursive, sans-serif;
            background-color: var(--color-white);
            color: var(--color-black);
            margin: 0;
            padding-bottom: 72px; /* フッターの高さ */
            /* フィルム粒子テクスチャの追加 */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100' height='100' filter='url(%23n)' opacity='0.08'/%3E%3C/svg%3E");
        }

        /* 太いインク線スタイル */
        .ink-border {
            border: 4px solid var(--color-black);
            border-radius: 8px; /* 丸みを少し加えてレトロ感を出す */
        }

        /* デジタルフォント風（フォールバック） */
        .retro-digital {
            font-family: 'DSEG7 Classic', 'Courier New', monospace;
            /* サイズを大きく変更 */
            font-size: 2.5rem; 
            letter-spacing: 2px;
            font-weight: 700;
        }

        /* 点滅コロンアニメーション */
        @keyframes blink {
            0%, 49% { color: var(--color-red); }
            50%, 100% { color: var(--color-black); }
        }
        .blinking-colon {
            animation: blink 1s step-end infinite;
            display: inline-block;
            width: 8px; /* コロンの幅を調整 */
        }

        /* モバイルビューの最適化 */
        #app-container {
            max-width: 600px;
            min-height: 100vh;
            margin: 0 auto;
            background-color: var(--color-white);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        /* ビューコンテナ */
        .view-content {
            padding: 16px;
            min-height: calc(100vh - 128px); /* ヘッダーとフッターを考慮 */
        }

        /* スロット分析のハイライト */
        .slot-highlight {
            background-color: rgba(255, 199, 44, 0.4); /* 黄色の半透明 */
            position: absolute;
            z-index: 10;
        }

        /* コマ撮り風アニメーション: 状態切り替えで視覚的なジャンプを発生させる */
        .steamboat-button {
            transition: all 0.05s steps(2); /* 0.05秒の短いトランジション、2ステップでカクカク動かす */
        }
        .steamboat-button:active {
            transform: scale(0.95);
        }

        /* 天気アイコンのスタイル */
        .weather-icon {
            font-size: 24px;
            line-height: 1;
        }
    </style>
</head>
<body class="bg-gray-900">
    <div id="app-container" class="ink-border shadow-2xl">

        <!-- ヘッダー (現在時刻表示のみ) -->
        <header class="p-3 bg-white ink-border-b sticky top-0 z-20 flex justify-end items-center">
            <!-- タイトルを削除しました -->
            <!-- text-3xl に変更し、秒数表示に対応 -->
            <div id="current-time" class="retro-digital text-3xl text-right">00<span class="blinking-colon">:</span>00<span class="blinking-colon">:</span>00</div>
        </header>

        <!-- メインコンテンツビューコンテナ -->
        <main id="view-container" class="view-content relative"></main>

        <!-- フッター (ナビゲーション) -->
        <footer class="fixed bottom-0 left-0 right-0 h-16 bg-white ink-border-t z-50 flex justify-around shadow-2xl mx-auto" style="max-width: 600px;">
            <button onclick="setView('month')" id="nav-month" class="flex-1 flex flex-col items-center justify-center p-2 steamboat-button text-gray-400 border-r border-gray-200">
                <span class="text-2xl">📅</span><span class="text-xs font-bold mt-1">月</span>
            </button>
            <button onclick="setView('week')" id="nav-week" class="flex-1 flex flex-col items-center justify-center p-2 steamboat-button text-gray-400 border-r border-gray-200">
                <span class="text-2xl">🗓️</span><span class="text-xs font-bold mt-1">週</span>
            </button>
            <button onclick="setView('task')" id="nav-task" class="flex-1 flex flex-col items-center justify-center p-2 steamboat-button text-gray-400 border-r border-gray-200">
                <span class="text-2xl">📝</span><span class="text-xs font-bold mt-1">タスク</span>
            </button>
            <button onclick="setView('log')" id="nav-log" class="flex-1 flex flex-col items-center justify-center p-2 steamboat-button text-gray-400">
                <span class="text-2xl">🕰️</span><span class="text-xs font-bold mt-1">日誌</span>
            </button>
        </footer>

        <!-- モーダルコンテナ (イベントCRUD / 詳細表示) -->
        <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-70 z-50 hidden flex items-center justify-center p-4">
            <div id="modal-content" class="bg-white ink-border w-full max-w-sm p-4 overflow-y-auto max-h-[90vh]">
                <!-- モーダル内容はJSで挿入されます -->
            </div>
        </div>
    </div>

    <script>
        // =======================================================
        // 0. 初期設定とユーティリティ
        // =======================================================

        const storageKey = 'steamboatPlannerData';
        const defaultLocation = '新浦安駅'; // モックデータ起点の場所

        let appData = {
            schedules: [],
            currentView: 'month',
            lastId: 0,
            currentDate: new Date()
        };

        // UI要素の取得
        const viewContainer = document.getElementById('view-container');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');

        /**
         * データをlocalStorageからロード
         */
        function loadData() {
            try {
                const storedData = localStorage.getItem(storageKey);
                if (storedData) {
                    const parsedData = JSON.parse(storedData);
                    // データの破損や不足を防ぐためのチェック
                    if (parsedData.schedules && Array.isArray(parsedData.schedules)) {
                        appData = { ...appData, ...parsedData };
                    }
                }
            } catch (e) {
                console.error("Failed to load data from localStorage", e);
                // データロード失敗時は初期データを使用
            }
        }

        /**
         * データをlocalStorageに保存
         */
        function saveData() {
            try {
                localStorage.setItem(storageKey, JSON.stringify(appData));
            } catch (e) {
                console.error("Failed to save data to localStorage", e);
            }
        }

        /**
         * 現在時刻をヘッダーに表示（赤い点滅コロン付き）
         */
        function updateCurrentTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0'); // 秒数を取得

            // 時分秒すべてを表示し、間に点滅コロンを挿入
            const timeString = `${hours}<span class="blinking-colon">:</span>${minutes}<span class="blinking-colon">:</span>${seconds}`;
            document.getElementById('current-time').innerHTML = timeString;
        }

        /**
         * 指定された日付のYYYY-MM-DD形式の文字列を返す
         * @param {Date} date
         * @returns {string}
         */
        function formatDate(date) {
            return date.getFullYear() + '-' +
                   String(date.getMonth() + 1).padStart(2, '0') + '-' +
                   String(date.getDate()).padStart(2, '0');
        }

        /**
         * 指定された日時のYYYY-MM-DDTHH:MM形式の文字列を返す
         * @param {Date} date
         * @returns {string}
         */
        function formatDateTimeLocal(date) {
            return date.getFullYear() + '-' +
                   String(date.getMonth() + 1).padStart(2, '0') + '-' +
                   String(date.getDate()).padStart(2, '0') + 'T' +
                   String(date.getHours()).padStart(2, '0') + ':' +
                   String(date.getMinutes()).padStart(2, '0');
        }

        // =======================================================
        // 1. データ操作 (CRUD)
        // =======================================================

        /**
         * スケジュール/タスクを登録または更新
         * @param {Object} eventData - イベントデータ
         */
        function saveEvent(eventData) {
            if (eventData.id) {
                // 更新
                const index = appData.schedules.findIndex(e => e.id === eventData.id);
                if (index !== -1) {
                    appData.schedules[index] = eventData;
                }
            } else {
                // 新規登録
                appData.lastId++;
                eventData.id = appData.lastId;
                appData.schedules.push(eventData);
            }
            saveData();
            closeModal();
            renderView(appData.currentView);
        }

        /**
         * スケジュール/タスクを削除
         * @param {number} id - イベントID
         */
        function deleteEvent(id) {
            // 確認モーダルの代わりにカスタムメッセージボックスを使用
            showCustomMessageBox('確認', 'この予定を削除しますか？', () => {
                appData.schedules = appData.schedules.filter(e => e.id !== id);
                saveData();
                closeModal();
                renderView(appData.currentView);
            });
        }

        /**
         * タスクの完了状態をトグル
         * @param {number} id - タスクID
         */
        function toggleTask(id) {
            const task = appData.schedules.find(e => e.id === id);
            if (task) {
                task.completed = !task.completed;
                if (task.completed) {
                    task.actualEnd = new Date().toISOString(); // 完了時刻を記録
                } else {
                    task.actualEnd = null;
                }
                saveEvent(task);
            }
        }

        // =======================================================
        // 2. モーダル/UI処理
        // =======================================================

        /**
         * モーダルを開く
         * @param {string} contentHtml - モーダルに表示するHTMLコンテンツ
         */
        function openModal(contentHtml) {
            modalContent.innerHTML = contentHtml;
            modalOverlay.classList.remove('hidden');
        }

        /**
         * モーダルを閉じる
         */
        function closeModal() {
            modalOverlay.classList.add('hidden');
            modalContent.innerHTML = '';
        }

        // モーダル外クリックで閉じる
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                closeModal();
            }
        });

        /**
         * イベント登録/編集フォームの表示
         * @param {number|null} id - 編集の場合はID, 新規の場合はnull
         * @param {Date} [initialDate] - 新規作成時の初期日付
         */
        function showEventForm(id = null, initialDate = appData.currentDate) {
            const event = id ? appData.schedules.find(e => e.id === id) : null;
            const isTask = event ? event.type === 'task' : false;

            const now = new Date();
            const defaultStart = new Date(initialDate.getFullYear(), initialDate.getMonth(), initialDate.getDate(), now.getHours() + 1, 0);
            const defaultEnd = new Date(defaultStart.getTime() + 60 * 60 * 1000);

            const startTime = event ? new Date(event.start) : defaultStart;
            const endTime = event ? new Date(event.end) : defaultEnd;

            const formHtml = `
                <h2 class="text-xl font-extrabold ink-border-b pb-2 mb-4">${id ? '予定を編集' : '新しい予定/タスク'}</h2>
                <form id="event-form">
                    <input type="hidden" name="id" value="${id || ''}">

                    <div class="mb-4">
                        <label class="block mb-1 font-bold">種類</label>
                        <div class="flex space-x-4">
                            <label class="flex items-center">
                                <input type="radio" name="type" value="schedule" ${!isTask ? 'checked' : ''} class="mr-2 border-2 border-black" required> 予定
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="type" value="task" ${isTask ? 'checked' : ''} class="mr-2 border-2 border-black"> タスク
                            </label>
                        </div>
                    </div>

                    <div class="mb-4">
                        <label for="title" class="block mb-1 font-bold">タイトル</label>
                        <input type="text" id="title" name="title" value="${event ? event.title : ''}"
                               class="ink-border p-2 w-full" placeholder="タイトルを入力" required>
                    </div>

                    <div id="datetime-fields">
                        <div class="mb-4">
                            <label for="start" class="block mb-1 font-bold">開始日時</label>
                            <input type="datetime-local" id="start" name="start" value="${formatDateTimeLocal(startTime)}"
                                   class="ink-border p-2 w-full" required>
                        </div>
                        <div class="mb-4">
                            <label for="end" class="block mb-1 font-bold">終了日時</label>
                            <input type="datetime-local" id="end" name="end" value="${formatDateTimeLocal(endTime)}"
                                   class="ink-border p-2 w-full" required>
                        </div>
                    </div>

                    <div class="mb-4">
                        <label for="location" class="block mb-1 font-bold">場所</label>
                        <input type="text" id="location" name="location" value="${event ? event.location || '' : ''}"
                               class="ink-border p-2 w-full" placeholder="場所（任意）">
                    </div>

                    <div class="mb-4">
                        <label for="notes" class="block mb-1 font-bold">備考</label>
                        <textarea id="notes" name="notes" class="ink-border p-2 w-full" rows="3" placeholder="詳細、メモ">${event ? event.notes || '' : ''}</textarea>
                    </div>

                    <div class="flex justify-between items-center pt-2 border-t border-gray-300">
                        <button type="button" onclick="closeModal()" class="steamboat-button bg-gray-200 text-black px-4 py-2 ink-border">キャンセル</button>
                        <button type="submit" class="steamboat-button bg-[var(--color-red)] text-white px-4 py-2 ink-border shadow-md">保存</button>
                    </div>
                </form>
            `;

            openModal(formHtml);

            document.getElementById('event-form').addEventListener('submit', function(e) {
                e.preventDefault();
                const formData = new FormData(this);
                const data = {
                    id: formData.get('id') ? parseInt(formData.get('id')) : null,
                    title: formData.get('title'),
                    type: formData.get('type'),
                    start: new Date(formData.get('start')).toISOString(),
                    end: new Date(formData.get('end')).toISOString(),
                    location: formData.get('location'),
                    notes: formData.get('notes'),
                    completed: event ? event.completed : false,
                    actualEnd: event ? event.actualEnd : null,
                };
                saveEvent(data);
            });
        }

        /**
         * イベント詳細モーダルの表示
         * @param {number} id - イベントID
         */
        function showEventDetails(id) {
            const event = appData.schedules.find(e => e.id === id);
            if (!event) return;

            const isTask = event.type === 'task';
            const start = new Date(event.start);
            const end = new Date(event.end);
            const dateStr = `${start.getMonth() + 1}月${start.getDate()}日`;
            const timeStr = `${String(start.getHours()).padStart(2, '0')}:${String(start.getMinutes()).padStart(2, '0')} - ${String(end.getHours()).padStart(2, '0')}:${String(end.getMinutes()).padStart(2, '0')}`;

            // モックデータ生成
            const { time, route } = getMockRouteInfo(event.location);
            const weather = getMockWeather(start, event.location);

            const weatherWarning = weather.warning ? 'bg-[var(--color-yellow)] text-black font-bold p-1 rounded-sm' : 'text-black';

            const detailHtml = `
                <h2 class="text-2xl font-extrabold ink-border-b pb-2 mb-4">${event.title}</h2>
                <p class="text-sm text-gray-600 mb-4">${isTask ? 'タスク' : '予定'}</p>

                <div class="space-y-3 mb-4">
                    <p class="flex justify-between items-center"><span class="font-bold">📅 日付:</span> <span>${dateStr}</span></p>
                    <p class="flex justify-between items-center"><span class="font-bold">⏱️ 時間:</span> <span>${timeStr}</span></p>
                    <p class="flex justify-between items-center"><span class="font-bold">📍 場所:</span> <span>${event.location || '未定'}</span></p>
                    ${event.notes ? `<p class="font-bold border-t pt-3">📝 備考:</p><p class="whitespace-pre-wrap">${event.notes}</p>` : ''}
                </div>

                <!-- 外部情報連携 (モック) -->
                <div class="ink-border p-3 mt-4 bg-gray-100">
                    <h3 class="font-extrabold text-lg ink-border-b border-dashed pb-2 mb-3">レトロ情報連携</h3>

                    <!-- 天気予報モック -->
                    <div class="flex items-center justify-between mb-3">
                        <span class="font-bold">天気予報:</span>
                        <div class="flex items-center space-x-2 ${weatherWarning}">
                            <span class="weather-icon text-2xl">${weather.icon}</span>
                            <span>${weather.condition} | ${weather.temp}°C (${weather.rain}% 降水)</span>
                        </div>
                    </div>

                    <!-- 経路・時間検索モック -->
                    <div>
                        <p class="font-bold mb-1">🚗 新浦安駅からの所要時間 (モック):</p>
                        <p class="text-sm bg-white p-2 ink-border">
                            ${time}
                            <span class="block text-xs text-gray-600 mt-1">${route}</span>
                        </p>
                    </div>
                </div>

                <div class="flex justify-between mt-6">
                    <button onclick="showEventForm(${event.id})" class="steamboat-button bg-[var(--color-yellow)] text-black px-4 py-2 ink-border font-bold">編集</button>
                    ${isTask ? `<button onclick="toggleTask(${event.id})" class="steamboat-button bg-green-500 text-white px-4 py-2 ink-border font-bold">${event.completed ? '未完了に戻す' : '完了として記録'}</button>` : ''}
                    <button onclick="deleteEvent(${event.id})" class="steamboat-button bg-gray-800 text-white px-4 py-2 ink-border font-bold">削除</button>
                </div>
            `;
            openModal(detailHtml);
        }

        /**
         * カスタムメッセージボックスを表示 (alert/confirmの代わり)
         * @param {string} title
         * @param {string} message
         * @param {Function} onConfirm - 確認時のコールバック
         * @param {Function} [onCancel] - キャンセル時のコールバック
         */
        function showCustomMessageBox(title, message, onConfirm, onCancel = closeModal) {
            const messageBoxHtml = `
                <h2 class="text-xl font-extrabold ink-border-b pb-2 mb-4">${title}</h2>
                <p class="mb-6">${message}</p>
                <div class="flex justify-end space-x-4">
                    <button onclick="closeModal(); ${onCancel ? onCancel.name + '()' : ''}" class="steamboat-button bg-gray-200 text-black px-4 py-2 ink-border">キャンセル</button>
                    <button onclick="${onConfirm.name}(); closeModal();" class="steamboat-button bg-[var(--color-red)] text-white px-4 py-2 ink-border shadow-md">OK</button>
                </div>
            `;
            openModal(messageBoxHtml);
        }


        // =======================================================
        // 3. 外部情報連携モック
        // =======================================================

        /**
         * モックの経路・時間検索 (新浦安駅起点)
         * @param {string} destination - 目的地
         * @returns {{time: string, route: string}}
         */
        function getMockRouteInfo(destination) {
            if (!destination) {
                return { time: '場所が未入力です', route: '経路情報なし' };
            }
            const hash = destination.length % 5;
            let time, route;
            switch (hash) {
                case 0:
                    time = '電車で約45分 (乗換1回)';
                    route = `${defaultLocation} → (JR京葉線) → 〇〇駅`;
                    break;
                case 1:
                    time = 'バスで約20分 (直行)';
                    route = `${defaultLocation} バス停 → 目的地周辺`;
                    break;
                case 2:
                    time = '徒歩で約5分';
                    route = `目的地は${defaultLocation}の近隣です`;
                    break;
                case 3:
                    time = '電車とバスで約1時間15分 (乗換2回)';
                    route = `${defaultLocation} → (JR線) → 〇〇駅 → (バス) → 目的地`;
                    break;
                default:
                    time = '電車で約30分 (乗換なし)';
                    route = `${defaultLocation} → (JR線) → 目的地駅`;
                    break;
            }
            return { time, route };
        }

        /**
         * モックの天気予報
         * @param {Date} date - 予定の日時
         * @param {string} location - 予定の場所 (モックでは使用しない)
         * @returns {{icon: string, condition: string, temp: number, rain: number, warning: boolean}}
         */
        function getMockWeather(date, location) {
            const dayOfMonth = date.getDate();
            const hour = date.getHours();

            let condition, icon, rain, temp, warning = false;

            if (dayOfMonth % 7 === 0) {
                // 7の倍数の日は雨
                condition = '大雨';
                icon = '🌧️';
                rain = 80;
                temp = 18;
                warning = true; // 悪天候時は黄色警告
            } else if (dayOfMonth % 3 === 0) {
                // 3の倍数の日は曇り
                condition = '曇り';
                icon = '☁️';
                rain = 10;
                temp = 25;
            } else {
                // それ以外は晴れ
                condition = '晴れ';
                icon = '☀️';
                rain = 0;
                temp = (hour < 10 || hour > 18) ? 20 : 28;
            }

            return { icon, condition, temp, rain, warning };
        }

        // =======================================================
        // 4. 高度な時間管理機能 (スロット分析)
        // =======================================================

        /**
         * 指定された日の空き時間帯 (スロット) を分析
         * @param {Date} targetDate - 対象の日付
         * @returns {Array<{start: Date, end: Date}>} - 空き時間スロットの配列
         */
        function analyzeTimeSlots(targetDate) {
            const slots = [];
            const dayStartHour = 9; // 分析開始時刻
            const dayEndHour = 22; // 分析終了時刻

            const dayStart = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), dayStartHour, 0);
            const dayEnd = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate(), dayEndHour, 0);

            // 対象日の確定した予定（未完了のスケジュール、開始日時順）
            const bookedTimes = appData.schedules
                .filter(e => e.type === 'schedule' || e.type === 'task')
                .filter(e => {
                    const start = new Date(e.start);
                    return start >= dayStart && start < new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);
                })
                .map(e => ({
                    start: new Date(e.start),
                    end: new Date(e.end)
                }))
                .sort((a, b) => a.start.getTime() - b.start.getTime());

            let currentCheckTime = dayStart;
            const minSlotDuration = 30 * 60 * 1000; // 30分以上の空き

            for (const booked of bookedTimes) {
                const gapDuration = booked.start.getTime() - currentCheckTime.getTime();

                // 予定と予定の間、または一日の始まりと最初の予定の間に空きがあるか
                if (gapDuration >= minSlotDuration) {
                    slots.push({
                        start: currentCheckTime,
                        end: booked.start
                    });
                }
                // チェック開始時間を現在の予定の終了時刻に進める (重複考慮のため)
                if (booked.end.getTime() > currentCheckTime.getTime()) {
                    currentCheckTime = booked.end;
                }
            }

            // 最後の予定の終了時刻から一日の終わりまでの空き
            const endGapDuration = dayEnd.getTime() - currentCheckTime.getTime();
            if (endGapDuration >= minSlotDuration) {
                slots.push({
                    start: currentCheckTime,
                    end: dayEnd
                });
            }

            return slots;
        }

        // =======================================================
        // 5. ビューレンダリング
        // =======================================================

        /**
         * 現在のビューを設定し、レンダリングをトリガー
         * @param {string} view - 'month', 'week', 'task', 'log'
         */
        function setView(view) {
            appData.currentView = view;
            document.querySelectorAll('footer button').forEach(btn => {
                btn.classList.remove('text-[var(--color-red)]', 'font-extrabold');
                btn.classList.add('text-gray-400');
            });
            document.getElementById(`nav-${view}`).classList.remove('text-gray-400');
            document.getElementById(`nav-${view}`).classList.add('text-[var(--color-red)]', 'font-extrabold');

            renderView(view);
        }

        /**
         * メインビューのコンテンツをレンダリング
         * @param {string} view - 'month', 'week', 'task', 'log'
         */
        function renderView(view) {
            viewContainer.innerHTML = ''; // コンテンツをクリア

            const headerHtml = (title) => `
                <div class="flex justify-between items-center mb-4 ink-border p-2 bg-gray-50">
                    <button onclick="changeDate(-1)" class="text-2xl steamboat-button">◀</button>
                    <h2 class="text-xl font-extrabold">${title}</h2>
                    <button onclick="changeDate(1)" class="text-2xl steamboat-button">▶</button>
                </div>
            `;

            switch (view) {
                case 'month':
                    renderMonthView(headerHtml);
                    break;
                case 'week':
                    renderWeekView(headerHtml);
                    break;
                case 'task':
                    renderTaskView();
                    break;
                case 'log':
                    renderLogView();
                    break;
            }

            // どのビューでも新規作成ボタンは表示
            const createButton = document.createElement('button');
            createButton.className = 'fixed right-6 bottom-20 w-12 h-12 bg-[var(--color-red)] text-white text-3xl font-extrabold rounded-full shadow-lg ink-border steamboat-button z-40';
            createButton.innerHTML = '+';
            createButton.onclick = () => showEventForm(null, appData.currentDate);
            viewContainer.appendChild(createButton);
        }

        /**
         * 月ビューのレンダリング
         */
        function renderMonthView(headerHtml) {
            const date = appData.currentDate;
            const year = date.getFullYear();
            const month = date.getMonth();
            const today = new Date();

            const firstDayOfMonth = new Date(year, month, 1);
            const lastDayOfMonth = new Date(year, month + 1, 0);
            const startDayOfWeek = firstDayOfMonth.getDay(); // 0=日曜

            // ヘッダーと日付タイトル
            viewContainer.innerHTML = headerHtml(`${year}年${month + 1}月`);

            let html = '<div class="ink-border p-1 bg-white">';
            html += '<div class="grid grid-cols-7 text-center font-bold text-sm bg-gray-200 ink-border-b">';
            ['日', '月', '火', '水', '木', '金', '土'].forEach(day => {
                html += `<div class="p-2">${day}</div>`;
            });
            html += '</div>';

            html += '<div class="grid grid-cols-7">';

            // 前月の日付埋め
            for (let i = 0; i < startDayOfWeek; i++) {
                html += '<div class="h-20 border border-gray-200 bg-gray-50"></div>';
            }

            // 今月の日付
            for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
                const currentDate = new Date(year, month, day);
                const dayStr = formatDate(currentDate);
                const isToday = dayStr === formatDate(today);

                // その日の予定を取得
                const events = appData.schedules.filter(e => formatDate(new Date(e.start)) === dayStr);
                const eventHtml = events.slice(0, 2).map(e => `
                    <div onclick="event.stopPropagation(); showEventDetails(${e.id})"
                         class="text-xs truncate px-1 mt-0.5 rounded-sm cursor-pointer ${e.type === 'task' ? 'bg-[var(--color-yellow)] text-black' : 'bg-gray-800 text-white'}"
                         title="${e.title}">
                        ${e.type === 'task' ? 'T' : 'S'} ${e.title}
                    </div>
                `).join('');

                const dayClass = isToday ? 'bg-[var(--color-red)] text-white font-extrabold' : 'bg-white';
                html += `
                    <div class="h-20 border border-gray-200 p-0.5 relative cursor-pointer" onclick="showEventForm(null, new Date(${year}, ${month}, ${day}))">
                        <div class="w-6 h-6 rounded-full text-center text-xs flex items-center justify-center ${dayClass}">
                            ${day}
                        </div>
                        <div class="mt-0.5 space-y-0.5">
                            ${eventHtml}
                        </div>
                    </div>
                `;
            }

            html += '</div></div>';
            viewContainer.innerHTML += html;
        }

        /**
         * 週ビューのレンダリング
         */
        function renderWeekView(headerHtml) {
            const date = appData.currentDate;
            const today = new Date();
            const dayOfWeek = date.getDay(); // 0 (Sun) to 6 (Sat)
            const weekStart = new Date(date.getFullYear(), date.getMonth(), date.getDate() - dayOfWeek); // 今週の日曜

            const weekDates = Array(7).fill(0).map((_, i) => {
                const d = new Date(weekStart);
                d.setDate(weekStart.getDate() + i);
                return d;
            });

            viewContainer.innerHTML = headerHtml(`週間 ${weekDates[0].getMonth() + 1}/${weekDates[0].getDate()} - ${weekDates[6].getMonth() + 1}/${weekDates[6].getDate()}`);

            let html = '<div class="overflow-x-auto"><div class="min-w-[500px] ink-border bg-white">';

            // 曜日ヘッダー
            html += '<div class="grid grid-cols-8 text-center font-bold text-sm bg-gray-200 ink-border-b">';
            html += '<div class="p-2 border-r border-gray-300">時間</div>';
            ['日', '月', '火', '水', '木', '金', '土'].forEach((day, i) => {
                const d = weekDates[i];
                const dayStr = formatDate(d);
                const isToday = dayStr === formatDate(today);
                const dayClass = isToday ? 'text-[var(--color-red)] font-extrabold' : 'text-black';
                html += `<div class="p-2 border-r border-gray-300 ${dayClass}">${day}<br>${d.getDate()}</div>`;
            });
            html += '</div>';

            // タイムライン
            html += '<div class="relative">';
            const hourStart = 8;
            const hourEnd = 23;
            for (let h = hourStart; h < hourEnd; h++) {
                html += `<div class="grid grid-cols-8 h-12 border-b border-gray-200">`;
                html += `<div class="p-1 text-xs text-right border-r border-gray-300 relative"><span class="absolute right-1 -top-2">${h}:00</span></div>`; // 時間表示

                for (let i = 0; i < 7; i++) {
                    const d = weekDates[i];
                    const dayStr = formatDate(d);
                    const isToday = dayStr === formatDate(today);
                    const colClass = isToday ? 'bg-yellow-50/50' : '';

                    // その日その時間の予定を取得
                    const startOfDay = new Date(d.getFullYear(), d.getMonth(), d.getDate(), h, 0);
                    const endOfHour = new Date(d.getFullYear(), d.getMonth(), d.getDate(), h, 59, 59);

                    const events = appData.schedules
                        .filter(e => new Date(e.start) < endOfHour && new Date(e.end) > startOfDay)
                        .map(e => ({
                            ...e,
                            start: new Date(e.start),
                            end: new Date(e.end)
                        }));

                    let eventsHtml = '';
                    events.forEach(e => {
                        // 1時間内の予定の開始・終了位置を計算
                        const startMin = e.start.getMinutes();
                        const endMin = e.end.getMinutes();
                        let top = (startMin / 60) * 100;
                        let height = ((e.end.getTime() - e.start.getTime()) / (60 * 60 * 1000)) * 100;

                        // 複数の日にまたがるイベントの調整 (ここでは1時間スロットに収めるため簡略化)
                        const startOnThisHour = Math.max(startOfDay.getTime(), e.start.getTime());
                        const endOnThisHour = Math.min(endOfHour.getTime(), e.end.getTime());

                        if (endOnThisHour > startOnThisHour) {
                            const duration = endOnThisHour - startOnThisHour;
                            top = ((startOnThisHour - startOfDay.getTime()) / (60 * 60 * 1000)) * 100;
                            height = (duration / (60 * 60 * 1000)) * 100;

                            // 100%を超えないように調整
                            if (top + height > 100) height = 100 - top;
                            if (top < 0) {
                                height += top;
                                top = 0;
                            }


                            eventsHtml += `
                                <div onclick="event.stopPropagation(); showEventDetails(${e.id})"
                                    class="absolute w-full px-1 text-xs truncate bg-gray-800 text-white rounded-sm cursor-pointer z-20"
                                    style="top: ${top}%; height: ${height}%; left: 0px; box-sizing: border-box;"
                                    title="${e.title}">
                                    ${e.title}
                                </div>
                            `;
                        }
                    });

                    html += `<div class="relative border-r border-gray-300 h-full ${colClass}">${eventsHtml}</div>`;
                }
                html += `</div>`;
            }
            html += '</div></div></div>'; // end of min-w-[500px], end of overflow-x-auto, end of relative
            viewContainer.innerHTML += html;


            // --- スロット分析のレンダリング (週ビューのみに適用) ---
            const timeLineContainer = viewContainer.querySelector('.relative');
            const dayWidth = timeLineContainer.offsetWidth / 8; // 8列 (時間+7日)
            const hourHeight = 48; // h-12 (48px)

            weekDates.forEach((d, i) => {
                const slots = analyzeTimeSlots(d);
                const colIndex = i + 1; // 0は時間列

                slots.forEach(slot => {
                    const start = slot.start;
                    const end = slot.end;

                    // 9:00を基準とした相対位置を計算 (h=8が開始時間)
                    const totalMinutesFromStart = ((start.getHours() - hourStart) * 60) + start.getMinutes();
                    const durationMinutes = (end.getTime() - start.getTime()) / (60 * 1000);

                    if (totalMinutesFromStart >= 0 && durationMinutes > 0) {
                        const topPosition = (totalMinutesFromStart / 60) * hourHeight;
                        const height = (durationMinutes / 60) * hourHeight;
                        const leftPosition = colIndex * dayWidth;

                        const slotDiv = document.createElement('div');
                        slotDiv.className = 'slot-highlight absolute';
                        slotDiv.style.top = `${topPosition}px`;
                        slotDiv.style.left = `${leftPosition}px`;
                        slotDiv.style.width = `${dayWidth}px`;
                        slotDiv.style.height = `${height}px`;
                        slotDiv.title = `空きスロット: ${start.toTimeString().slice(0, 5)} - ${end.toTimeString().slice(0, 5)}`;
                        timeLineContainer.appendChild(slotDiv);
                    }
                });
            });
        }

        /**
         * タスクビューのレンダリング
         */
        function renderTaskView() {
            const tasks = appData.schedules.filter(e => e.type === 'task');
            const pendingTasks = tasks.filter(t => !t.completed).sort((a, b) => new Date(a.end) - new Date(b.end));
            const completedTasks = tasks.filter(t => t.completed).sort((a, b) => new Date(b.actualEnd) - new Date(a.actualEnd));

            let html = '<h2 class="text-xl font-extrabold ink-border-b pb-2 mb-4">タスク管理 (Todoリスト)</h2>';

            // 未完了タスク
            html += '<div class="mb-6">';
            html += '<h3 class="text-lg font-bold text-[var(--color-red)] mb-2">🔴 未完了タスク</h3>';
            if (pendingTasks.length === 0) {
                html += '<p class="text-gray-600 italic">素晴らしい！未完了タスクはありません。</p>';
            } else {
                pendingTasks.forEach(task => {
                    const endDate = new Date(task.end);
                    const deadline = `${endDate.getMonth() + 1}/${endDate.getDate()} ${String(endDate.getHours()).padStart(2, '0')}:${String(endDate.getMinutes()).padStart(2, '0')}`;
                    html += `
                        <div class="ink-border p-3 mb-2 flex justify-between items-center bg-white cursor-pointer steamboat-button" onclick="showEventDetails(${task.id})">
                            <div class="flex-1">
                                <p class="font-bold">${task.title}</p>
                                <p class="text-xs text-gray-600">締切: ${deadline}</p>
                            </div>
                            <button onclick="event.stopPropagation(); toggleTask(${task.id})" class="steamboat-button bg-[var(--color-yellow)] text-black px-3 py-1 ink-border ml-3">
                                完了
                            </button>
                        </div>
                    `;
                });
            }
            html += '</div>';

            // 完了済みタスク
            html += '<div>';
            html += '<h3 class="text-lg font-bold text-[var(--color-yellow)] mb-2">🟡 完了済み (最近5件)</h3>';
            completedTasks.slice(0, 5).forEach(task => {
                const actualEnd = new Date(task.actualEnd);
                const completedTime = `${actualEnd.getMonth() + 1}/${actualEnd.getDate()} ${String(actualEnd.getHours()).padStart(2, '0')}:${String(actualEnd.getMinutes()).padStart(2, '0')}`;
                html += `
                    <div class="ink-border p-3 mb-2 flex justify-between items-center bg-gray-100 line-through text-gray-500 cursor-pointer steamboat-button" onclick="showEventDetails(${task.id})">
                        <div class="flex-1">
                            <p class="font-bold">${task.title}</p>
                            <p class="text-xs">完了: ${completedTime}</p>
                        </div>
                        <button onclick="event.stopPropagation(); toggleTask(${task.id})" class="steamboat-button bg-gray-300 text-black px-3 py-1 ink-border ml-3 text-xs">
                            戻す
                        </button>
                    </div>
                `;
            });
            html += '</div>';

            viewContainer.innerHTML = html;
        }

        /**
         * 日誌ビューのレンダリング
         */
        function renderLogView() {
            // 完了した予定とタスクを結合し、実測時間（actualEnd）または終了時間（end）でソート
            const completedEvents = appData.schedules
                .filter(e => e.type === 'schedule' || (e.type === 'task' && e.completed))
                .map(e => ({
                    ...e,
                    logTime: new Date(e.actualEnd || e.end) // タスクはactualEnd、予定はendを使用
                }))
                .sort((a, b) => b.logTime.getTime() - a.logTime.getTime());

            let html = '<h2 class="text-xl font-extrabold ink-border-b pb-2 mb-4">日誌 (タイムライン振り返り)</h2>';

            if (completedEvents.length === 0) {
                html += '<p class="text-gray-600 italic">まだ記録された日誌はありません。予定を完了させましょう。</p>';
            } else {
                html += '<div class="relative border-l-4 border-[var(--color-black)] ml-6 p-2">';

                let lastDate = null;

                completedEvents.forEach(e => {
                    const logDate = e.logTime;
                    const logTimeStr = `${String(logDate.getHours()).padStart(2, '0')}:${String(logDate.getMinutes()).padStart(2, '0')}`;
                    const dateStr = `${logDate.getFullYear()}/${logDate.getMonth() + 1}/${logDate.getDate()}`;

                    // 日付の区切り線
                    if (dateStr !== lastDate) {
                        html += `
                            <div class="relative my-4">
                                <div class="absolute -left-8 top-1/2 w-4 h-4 rounded-full bg-[var(--color-red)] ink-border transform -translate-y-1/2"></div>
                                <h3 class="ml-4 font-extrabold text-sm bg-gray-200 inline-block px-2 py-0.5 ink-border-b">${dateStr}</h3>
                            </div>
                        `;
                        lastDate = dateStr;
                    }

                    // イベントアイテム
                    const itemClass = e.type === 'task' ? 'bg-[var(--color-yellow)] text-black' : 'bg-gray-800 text-white';
                    const durationMs = new Date(e.end).getTime() - new Date(e.start).getTime();
                    const durationHours = (durationMs / (1000 * 60 * 60)).toFixed(1);

                    html += `
                        <div class="relative mb-6">
                            <!-- タイムラインの丸ポチ -->
                            <div class="absolute -left-8 top-0 w-3 h-3 rounded-full bg-[var(--color-black)] transform translate-x-[2px] mt-1"></div>
                            <div class="ml-4 p-3 ink-border ${itemClass} shadow-lg steamboat-button" onclick="showEventDetails(${e.id})">
                                <p class="text-xs font-bold mb-1">${logTimeStr} - ${e.type === 'task' ? 'タスク完了' : '予定終了'}</p>
                                <p class="text-lg font-extrabold">${e.title}</p>
                                <p class="text-xs mt-1">⏰ 予定時間: ${durationHours} 時間</p>
                            </div>
                        </div>
                    `;
                });

                html += '</div>';
            }

            viewContainer.innerHTML = html;
        }

        /**
         * 日付の変更 (月ビューと週ビューの移動)
         * @param {number} offset - -1 (前へ) または 1 (次へ)
         */
        function changeDate(offset) {
            const currentView = appData.currentView;
            let newDate = new Date(appData.currentDate);

            if (currentView === 'month') {
                newDate.setMonth(newDate.getMonth() + offset);
            } else if (currentView === 'week') {
                newDate.setDate(newDate.getDate() + (offset * 7));
            } else {
                // タスクと日誌ビューでは変更なし
                return;
            }

            appData.currentDate = newDate;
            renderView(currentView);
        }

        // =======================================================
        // 6. 初期化と実行
        // =======================================================

        /**
         * 初期データを作成 (デモ用)
         */
        function initializeDemoData() {
            if (appData.schedules.length > 0) return; // 既存データがあればスキップ

            const now = new Date();
            const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);
            const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);

            // 予定 (スケジュール)
            appData.schedules.push({
                id: 1, title: 'クライアントとのミーティング', type: 'schedule',
                start: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 10, 0).toISOString(),
                end: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 11, 30).toISOString(),
                location: '大手町ビル', notes: '新プロジェクトのキックオフ', completed: false, actualEnd: null
            });
            appData.schedules.push({
                id: 2, title: 'チームランチ', type: 'schedule',
                start: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 12, 0).toISOString(),
                end: new Date(now.getFullYear(), now.getMonth(), now.getDate(), 13, 0).toISOString(),
                location: '社食', notes: '', completed: false, actualEnd: null
            });

            // タスク (未完了)
            appData.schedules.push({
                id: 3, title: '週報のドラフト作成', type: 'task',
                start: tomorrow.toISOString(),
                end: new Date(tomorrow.getFullYear(), tomorrow.getMonth(), tomorrow.getDate(), 15, 0).toISOString(),
                location: '自宅', notes: '分析データを含めること', completed: false, actualEnd: null
            });
            appData.schedules.push({
                id: 4, title: '来週のプレゼン資料準備', type: 'task',
                start: nextWeek.toISOString(),
                end: new Date(nextWeek.getFullYear(), nextWeek.getMonth(), nextWeek.getDate(), 10, 0).toISOString(),
                location: '', notes: 'アニメーションを工夫', completed: false, actualEnd: null
            });

            // タスク (完了済み)
            const completedTime = new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000); // 2日前の時間
            appData.schedules.push({
                id: 5, title: 'メールの返信処理', type: 'task',
                start: completedTime.toISOString(),
                end: completedTime.toISOString(),
                location: '', notes: '緊急度の高いもの優先', completed: true, actualEnd: new Date(completedTime.getTime() + 10 * 60 * 1000).toISOString()
            });

            appData.lastId = 5;
            saveData();
        }

        // アプリケーションの開始
        window.onload = function() {
            // データロードと初期データ作成
            loadData();
            initializeDemoData(); // デモデータ

            // 現在時刻の更新ループ
            updateCurrentTime();
            setInterval(updateCurrentTime, 1000);

            // 初期ビューのレンダリング
            setView(appData.currentView);
        };
    </script>
</body>
</html>
